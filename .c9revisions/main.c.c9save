{"ts":1366783520689,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"#include \"stm32f4xx.h\"\n#include \"stm32f4xx_usart.h\"\n#include \"stm32f4xx_gpio.h\"\n#include \"stm32f4xx_rcc.h\"\n#include \"stm32f4xx_i2c.h\"\n#include \"stm32f4xx_dma.h\"\n#include \"stm32f4xx_dcmi.h\"\n#include \"ov7670reg.h\"\n#include \"misc.h\"\n#include <stdio.h>\n// DMA Stream parameters definitions. You can modify these parameters to select\n// a different DMA Stream and/or channel.\n// But note that only DMA2 Streams are capable of Memory to Memory transfers.\n#define DMA_CameraToRAM_Stream   \t\tDMA2_Stream7\n#define DMA_Camera_Channel         \t\tDMA_Channel_1\n#define DMA_Camera_STREAM_CLOCK    \t\tRCC_AHB1Periph_DMA2\n#define DMA_Camera_STREAM_IRQ      \t\tDMA2_Stream7_IRQn\n#define DMA_Camera_IT_TCIF         \t\tDMA_IT_TCIF7\n#define DMA_Camera_STREAM_IRQHANDLER    DMA2_Stream7_IRQHandler\n#define DCMI_DR_ADDRESS       0x50050028\n#define TIMEOUT_MAX              10000\n#define HSI_STARTUP_TIMEOUT\t\t 10000\n#define picture_x 176\n#define picture_y 144\n//#define picture_x 160\n//#define picture_y 120\n__IO uint16_t RAM_Buffer[picture_x * picture_y];\n\nvoid usart_init(void) {\n\t/* USARTx configured as follow:\n\t - BaudRate = 115200 baud\n\t - Word Length = 8 Bits\n\t - One Stop Bit\n\t - No parity\n\t - Hardware flow control disabled (RTS and CTS signals)\n\t - Receive and transmit enabled\n\t */\n\tGPIO_InitTypeDef GPIO_InitStructure;\n\tUSART_InitTypeDef USART_InitStructure;\n\n\t/* Enable GPIO clock */\n\tRCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);\n\n\t/* Enable UART clock */\n\tRCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);\n\n\t/* Connect PXx to USARTx_Tx*/\n\tGPIO_PinAFConfig(GPIOD, GPIO_PinSource5, GPIO_AF_USART2);\n\n\t/* Connect PXx to USARTx_Rx*/\n\tGPIO_PinAFConfig(GPIOD, GPIO_PinSource6, GPIO_AF_USART2);\n\n\tUSART_OverSampling8Cmd(USART2, ENABLE);\n\t/* Configure USART Tx as alternate function  */\n\tGPIO_InitStructure.GPIO_OType = GPIO_OType_PP;\n\tGPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;\n\n\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;\n\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(GPIOD, &GPIO_InitStructure);\n\n\t/* Configure USART Rx as alternate function  */\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;\n\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;\n\tGPIO_Init(GPIOD, &GPIO_InitStructure);\n\n\tUSART_InitStructure.USART_BaudRate = 1200000;\n\tUSART_InitStructure.USART_WordLength = USART_WordLength_8b;\n\tUSART_InitStructure.USART_StopBits = USART_StopBits_1;\n\tUSART_InitStructure.USART_Parity = USART_Parity_No;\n\tUSART_InitStructure.USART_HardwareFlowControl =\n\t\t\tUSART_HardwareFlowControl_None;\n\tUSART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;\n\n\t/* USART configuration */\n\tUSART_Init(USART2, &USART_InitStructure);\n\n\t/* Enable USART */\n\tUSART_Cmd(USART2, ENABLE);\n\n}\nvoid usPrintChar(char c) {\n\tuint8_t ch;\n\tch = c;\n\t/* Place your implementation of fputc here */\n\t/* e.g. write a character to the USART */\n\tUSART_SendData(USART2, (uint8_t) ch);\n\n\t/* Loop until the end of transmission */\n\twhile (USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET) {\n\t}\n}\nvoid usartSendWord(uint16_t word) {\n\tuint8_t b1 = word & 0xFF;\n\tuint8_t b2 = word >> 8;\n\tusPrintChar(b1);\n\tusPrintChar(b2);\n}\n\nvoid I2CInit(void) {\n\n\tGPIO_InitTypeDef GPIO_InitStructure;\n\tI2C_InitTypeDef I2C_InitStructure;\n\n\t/* Enable GPIO clock */\n\tRCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);\n\n\t/* Enable UART clock */\n\tRCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, ENABLE);\n\n\tGPIO_PinAFConfig(GPIOB, GPIO_PinSource10, GPIO_AF_I2C2);\n\tGPIO_PinAFConfig(GPIOB, GPIO_PinSource11, GPIO_AF_I2C2);\n\n\tGPIO_InitStructure.GPIO_OType = GPIO_OType_OD;\n\tGPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;\n\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;\n\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(GPIOB, &GPIO_InitStructure);\n\n\tI2C_InitStructure.I2C_ClockSpeed = 400000;\n\tI2C_InitStructure.I2C_Mode = I2C_Mode_I2C;\n\tI2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;\n\tI2C_InitStructure.I2C_OwnAddress1 = 0;\n\tI2C_InitStructure.I2C_Ack = I2C_Ack_Enable;\n\tI2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;\n\n\t/* Enable I2C */\n\tI2C_Cmd(I2C2, ENABLE);\n\tI2C_Init(I2C2, &I2C_InitStructure);\n}\n\nvoid I2C_start(I2C_TypeDef* I2Cx, uint8_t address, uint8_t direction) {\n\twhile (I2C_GetFlagStatus(I2Cx, I2C_FLAG_BUSY))\n\t\t;\n\tI2C_GenerateSTART(I2Cx, ENABLE);\n\twhile (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_MODE_SELECT))\n\t\t;\n\tI2C_Send7bitAddress(I2Cx, address, direction);\n\tif (direction == I2C_Direction_Transmitter) {\n\t\twhile (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))\n\t\t\t;\n\t} else if (direction == I2C_Direction_Receiver) {\n\t\twhile (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))\n\t\t\t;\n\t}\n}\n\nvoid I2C_write(I2C_TypeDef* I2Cx, uint8_t data) {\n\tI2C_SendData(I2Cx, data);\n\t// ждем I2C EV8_2 --> ask от ведомого\n\twhile (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))\n\t\t;\n}\n\nuint8_t I2C_read_ack(I2C_TypeDef* I2Cx) {\n\tuint8_t data;\n\t// разрешаем ask после приема\n\tI2C_AcknowledgeConfig(I2Cx, ENABLE);\n\t// ждем пока ведомый передаст байт\n\twhile (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_BYTE_RECEIVED))\n\t\t;\n\t// возвращаем принятое\n\tdata = I2C_ReceiveData(I2Cx);\n\treturn data;\n}\n\nuint8_t I2C_read_nack(I2C_TypeDef* I2Cx) {\n\tuint8_t data;\n\t//запрещаем ask после приема\n\tI2C_AcknowledgeConfig(I2Cx, DISABLE);\n\t// ждем пока ведомый передаст байт\n\twhile (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_BYTE_RECEIVED))\n\t\t;\n\t// возвращаем принятое\n\tdata = I2C_ReceiveData(I2Cx);\n\treturn data;\n}\n\nvoid I2C_stop(I2C_TypeDef* I2Cx) {\n\t//Отправляем STOP на линию\n\tI2C_GenerateSTOP(I2Cx, ENABLE);\n}\n\nstatic ErrorStatus MCO_init(void) {\n\tErrorStatus status = ERROR;\n\tGPIO_InitTypeDef GPIO_InitStructure;\n\tRCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);\n\n\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;\n\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;\n\tGPIO_InitStructure.GPIO_OType = GPIO_OType_PP;\n\tGPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;\n\tGPIO_Init(GPIOA, &GPIO_InitStructure);\n\n\tRCC_MCO1Config(RCC_MCO1Source_PLLCLK, RCC_MCO1Div_4);\n\treturn (status);\n}\n\nvoid delay(unsigned int ms) {\n\t//4694 = 1 ms\n\twhile (ms > 1) {\n\t\tms--;\n\t\tasm(\"nop\");\n\t}\n}\n\nuint8_t ov7670_get(uint8_t reg) {\n\tuint8_t data = 0;\n\tI2C_start(I2C2, 0x42, I2C_Direction_Transmitter);\n\tI2C_write(I2C2, reg);\n\tI2C_stop(I2C2);\n\tdelay(1000);\n\tI2C_start(I2C2, 0x43, I2C_Direction_Receiver);\n\tdata = I2C_read_nack(I2C2);\n\tI2C_stop(I2C2);\n\tdelay(1000);\n\treturn data;\n}\nuint8_t ov7670_set(uint8_t reg, uint8_t data) {\n\tI2C_start(I2C2, 0x42, I2C_Direction_Transmitter);\n\tI2C_write(I2C2, reg);\n\tI2C_write(I2C2, data);\n\tI2C_stop(I2C2);\n\tdelay(1000);\n\treturn 0;\n}\n\nvoid DCMI_init() {\n\tGPIO_InitTypeDef GPIO_InitStructure;\n\tDMA_InitTypeDef DMA_InitStructure;\n\tDCMI_InitTypeDef DCMI_InitStructure;\n\t//DCMI_CROPInitTypeDef DCMI_CROPInitStructure;\n\n\t__IO\n\tuint32_t Timeout = TIMEOUT_MAX;\n\n\tRCC_AHB1PeriphClockCmd(\n\t\t\tRCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOB | RCC_AHB1Periph_GPIOC\n\t\t\t\t\t| RCC_AHB1Periph_GPIOE, ENABLE);\n\n\t// Connect DCMI pins to AF13\n\t// PORTA\n\tGPIO_PinAFConfig(GPIOA, GPIO_PinSource4, GPIO_AF_DCMI); // HSYNC\n\tGPIO_PinAFConfig(GPIOA, GPIO_PinSource6, GPIO_AF_DCMI); // PCLK\n\t//GPIO_PinAFConfig(GPIOA, GPIO_PinSource9, GPIO_AF_DCMI); // D0\n\t//GPIO_PinAFConfig(GPIOA, GPIO_PinSource10, GPIO_AF_DCMI); // D1\n\t// PORTB\n\tGPIO_PinAFConfig(GPIOB, GPIO_PinSource6, GPIO_AF_DCMI); // D5\n\tGPIO_PinAFConfig(GPIOB, GPIO_PinSource7, GPIO_AF_DCMI); // VSYNC\n\tGPIO_PinAFConfig(GPIOB, GPIO_PinSource8, GPIO_AF_DCMI); // D6\n\tGPIO_PinAFConfig(GPIOB, GPIO_PinSource9, GPIO_AF_DCMI); // D7\t\t\t\t   -\n\t// PORTC\n\tGPIO_PinAFConfig(GPIOC, GPIO_PinSource11, GPIO_AF_DCMI); // D4\n\tGPIO_PinAFConfig(GPIOC, GPIO_PinSource6, GPIO_AF_DCMI); // D0\n\tGPIO_PinAFConfig(GPIOC, GPIO_PinSource7, GPIO_AF_DCMI); // D1\n\t// PORTE\n\tGPIO_PinAFConfig(GPIOE, GPIO_PinSource0, GPIO_AF_DCMI); // D2\n\tGPIO_PinAFConfig(GPIOE, GPIO_PinSource1, GPIO_AF_DCMI); // D3\n\t// DCMI GPIO configuration\n\t// D0..D1(PA9/10), HSYNC(PA4), PCLK(PA6)\n\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_6 | GPIO_Pin_10;\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;\n\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;\n\tGPIO_InitStructure.GPIO_OType = GPIO_OType_PP;\n\tGPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;\n\tGPIO_Init(GPIOA, &GPIO_InitStructure);\n\t// D5..D7(PB6/8/9), VSYNC(PB7)\n\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8\n\t\t\t| GPIO_Pin_9;\n\tGPIO_Init(GPIOB, &GPIO_InitStructure);\n\t// D4(PC11)\n\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_6 | GPIO_Pin_7;\n\tGPIO_Init(GPIOC, &GPIO_InitStructure);\n\t// D2..D3(PE0/1)\n\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;\n\tGPIO_Init(GPIOE, &GPIO_InitStructure);\n\t//---------------------------------------------------------------------------------------\n\t//\tGPIO_PinAFConfig(GPIOC, GPIO_PinSource6, GPIO_AF_DCMI); //d0\n\t//\tGPIO_PinAFConfig(GPIOC, GPIO_PinSource7, GPIO_AF_DCMI);\t//d1\n\t//\tGPIO_PinAFConfig(GPIOC, GPIO_PinSource8, GPIO_AF_DCMI);\t//d2\n\n\t//---------------------------------------------------------------------------------------\n\t// Configures the DCMI to interface with the OV7670 camera module\n\t// Enable DCMI clock\n\tRCC_AHB2PeriphClockCmd(RCC_AHB2Periph_DCMI, ENABLE);\n\t// Reinitialize\n\tDCMI_DeInit();\n\n\tDCMI_InitStructure.DCMI_CaptureMode = DCMI_CaptureMode_Continuous;\n\tDCMI_InitStructure.DCMI_CaptureRate = DCMI_CaptureRate_All_Frame;\n\tDCMI_InitStructure.DCMI_ExtendedDataMode = DCMI_ExtendedDataMode_8b;\n\tDCMI_InitStructure.DCMI_HSPolarity = DCMI_HSPolarity_Low;\n\tDCMI_InitStructure.DCMI_PCKPolarity = DCMI_PCKPolarity_Rising;\n\tDCMI_InitStructure.DCMI_SynchroMode = DCMI_SynchroMode_Hardware;\n\tDCMI_InitStructure.DCMI_VSPolarity = DCMI_VSPolarity_High;\n\tDCMI_Init(&DCMI_InitStructure);\n\n\tRCC_AHB1PeriphClockCmd(DMA_Camera_STREAM_CLOCK, ENABLE);\n\tDMA_DeInit(DMA_CameraToRAM_Stream);\n\twhile (DMA_GetCmdStatus(DMA_CameraToRAM_Stream) != DISABLE) {\n\t}\n\tDMA_InitStructure.DMA_Channel = DMA_Camera_Channel;\n\tDMA_InitStructure.DMA_PeripheralBaseAddr = DCMI_DR_ADDRESS;\n\tDMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t) RAM_Buffer;\n\tDMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;\n\tDMA_InitStructure.DMA_BufferSize = picture_x * picture_y * 2 / 4;\n\tDMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;\n\tDMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;\n\tDMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;\n\tDMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;\n\tDMA_InitStructure.DMA_Mode = DMA_Mode_Circular;\n\tDMA_InitStructure.DMA_Priority = DMA_Priority_High;\n\tDMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Enable;\n\tDMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_Full;\n\tDMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;\n\tDMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;\n\tDMA_Init(DMA_CameraToRAM_Stream, &DMA_InitStructure);\n\n\tTimeout = TIMEOUT_MAX;\n\twhile ((DMA_GetCmdStatus(DMA_CameraToRAM_Stream) != ENABLE)\n\t\t\t&& (Timeout-- > 0)) {\n\t}\n\n\t// Check if a timeout condition occurred\n\tif (Timeout == 0) {\n\t\t// Manage the error: to simplify the code enter an infinite loop\n\t\twhile (1) {\n\t\t\t// Dopísa program\n\t\t}\n\t}\n}\n\nint main() {\n\tSystemInit();\n\tusart_init();\n\tI2CInit();\n\tMCO_init();\n\tDCMI_init();\n\n\tif (ov7670_get(REG_PID) != 0x76) {\n\t\tprintf(\" PANIC! REG_PID != 0x76!\\n\");\n\t\twhile (1)\n\t\t\t;\n\t}\n\tov7670_set(REG_COM7, COM7_RESET); /* reset to default values */\n\tov7670_set(REG_CLKRC, 0x01);\n\tov7670_set(REG_COM7, COM7_FMT_VGA | COM7_YUV); /* output format: YUCV */\n\tint hstart = 456, hstop = 24, vstart = 14, vstop = 494;\n\tunsigned char v;\n\tov7670_set(REG_HSTART, (hstart >> 3) & 0xff);\n\tov7670_set(REG_HSTOP, (hstop >> 3) & 0xff);\n\tv = ov7670_get(REG_HREF);\n\tv = (v & 0xc0) | ((hstop & 0x7) << 3) | (hstart & 0x7);\n\tov7670_set(REG_HREF, v);\n\n\tov7670_set(REG_VSTART, (vstart >> 2) & 0xff);\n\tov7670_set(REG_VSTOP, (vstop >> 2) & 0xff);\n\tv = ov7670_get(REG_VREF);\n\tv = (v & 0xf0) | ((vstop & 0x3) << 2) | (vstart & 0x3);\n\tov7670_set(REG_VREF, v);\n\tov7670_set(REG_COM3, COM3_SCALEEN | COM3_DCWEN);\n\tov7670_set(REG_COM14, COM14_DCWEN | 0x01); // divide by 4 [RFC]\n\tov7670_set(0x73, 0xf1);\n\tov7670_set(0xa2, 0x52);\n\tov7670_set(0x7b, 0x1c);\n\tov7670_set(0x7c, 0x28);\n\tov7670_set(0x7d, 0x3c);\n\tov7670_set(0x7f, 0x69);\n\tov7670_set(REG_COM9, 0x38);\n\tov7670_set(0xa1, 0x0b);\n\tov7670_set(0x74, 0x19);\n\tov7670_set(0x9a, 0x80);\n\tov7670_set(0x43, 0x14);\n\tov7670_set(REG_COM13, 0xc0);\n\tov7670_set(0x70, 0x3A);\n\tov7670_set(0x71, 0x35);\n\tov7670_set(0x72, 0x11); // downsample by 2\n\n\t/* Gamma curve values */\n\tov7670_set(0x7a, 0x20);\n\tov7670_set(0x7b, 0x10);\n\tov7670_set(0x7c, 0x1e);\n\tov7670_set(0x7d, 0x35);\n\tov7670_set(0x7e, 0x5a);\n\tov7670_set(0x7f, 0x69);\n\tov7670_set(0x80, 0x76);\n\tov7670_set(0x81, 0x80);\n\tov7670_set(0x82, 0x88);\n\tov7670_set(0x83, 0x8f);\n\tov7670_set(0x84, 0x96);\n\tov7670_set(0x85, 0xa3);\n\tov7670_set(0x86, 0xaf);\n\tov7670_set(0x87, 0xc4);\n\tov7670_set(0x88, 0xd7);\n\tov7670_set(0x89, 0xe8);\n\n\t/* AGC and AEC parameters.  Note we start by disabling those features,\n\t then turn them only after tweaking the values. */\n\tov7670_set(REG_COM8, COM8_FASTAEC | COM8_AECSTEP | COM8_BFILT);\n\tov7670_set(REG_GAIN, 0);\n\tov7670_set(REG_AECH, 0);\n\tov7670_set(REG_COM4, 0x40); /* magic reserved bit */\n\tov7670_set(REG_COM9, 0x18); /* 4x gain + magic rsvd bit */\n\tov7670_set(REG_BD50MAX, 0x05);\n\tov7670_set(REG_BD60MAX, 0x07);\n\tov7670_set(REG_AEW, 0x95);\n\tov7670_set(REG_AEB, 0x33);\n\tov7670_set(REG_VPT, 0xe3);\n\tov7670_set(REG_HAECC1, 0x78);\n\tov7670_set(REG_HAECC2, 0x68);\n\tov7670_set(0xa1, 0x03); /* magic */\n\tov7670_set(REG_HAECC3, 0xd8);\n\tov7670_set(REG_HAECC4, 0xd8);\n\tov7670_set(REG_HAECC5, 0xf0);\n\tov7670_set(REG_HAECC6, 0x90);\n\tov7670_set(REG_HAECC7, 0x94);\n\tov7670_set(REG_COM8,\n\t\t\tCOM8_FASTAEC | COM8_AECSTEP | COM8_BFILT | COM8_AGC | COM8_AEC);\n\n\t/* Almost all of these are magic \"reserved\" values.  */\n\tov7670_set(REG_COM5, 0x61);\n\tov7670_set(REG_COM6, 0x4b);\n\tov7670_set(0x16, 0x02);\n\tov7670_set(REG_MVFP, 0x07);\n\tov7670_set(0x21, 0x02);\n\tov7670_set(0x22, 0x91);\n\tov7670_set(0x29, 0x07);\n\tov7670_set(0x33, 0x0b);\n\tov7670_set(0x35, 0x0b);\n\tov7670_set(0x37, 0x1d);\n\tov7670_set(0x38, 0x71);\n\tov7670_set(0x39, 0x2a);\n\tov7670_set(REG_COM12, 0x78);\n\tov7670_set(0x4d, 0x40);\n\tov7670_set(0x4e, 0x20);\n\tov7670_set(REG_GFIX, 0);\n\tov7670_set(0x6b, 0x4a);\n\tov7670_set(0x74, 0x10);\n\tov7670_set(0x8d, 0x4f);\n\tov7670_set(0x8e, 0);\n\tov7670_set(0x8f, 0);\n\tov7670_set(0x90, 0);\n\tov7670_set(0x91, 0);\n\tov7670_set(0x96, 0);\n\tov7670_set(0x9a, 0);\n\tov7670_set(0xb0, 0x84);\n\tov7670_set(0xb1, 0x0c);\n\tov7670_set(0xb2, 0x0e);\n\tov7670_set(0xb3, 0x82);\n\tov7670_set(0xb8, 0x0a);\n\n\t/* Matrix coefficients */\n\tov7670_set(0x4f, 0x80);\n\tov7670_set(0x50, 0x80);\n\tov7670_set(0x51, 0);\n\tov7670_set(0x52, 0x22);\n\tov7670_set(0x53, 0x5e);\n\tov7670_set(0x54, 0x80);\n\tov7670_set(0x58, 0x9e);\n\n\t/* More reserved magic, some of which tweaks white balance */\n\tov7670_set(0x43, 0x0a);\n\tov7670_set(0x44, 0xf0);\n\tov7670_set(0x45, 0x34);\n\tov7670_set(0x46, 0x58);\n\tov7670_set(0x47, 0x28);\n\tov7670_set(0x48, 0x3a);\n\tov7670_set(0x59, 0x88);\n\tov7670_set(0x5a, 0x88);\n\tov7670_set(0x5b, 0x44);\n\tov7670_set(0x5c, 0x67);\n\tov7670_set(0x5d, 0x49);\n\tov7670_set(0x5e, 0x0e);\n\tov7670_set(0x6c, 0x0a);\n\tov7670_set(0x6d, 0x55);\n\tov7670_set(0x6e, 0x11);\n\tov7670_set(0x6f, 0x9f); /* \"9e for advance AWB\" */\n\tov7670_set(0x6a, 0x40);\n\tov7670_set(REG_BLUE, 0x40);\n\tov7670_set(REG_RED, 0x60);\n\tov7670_set(REG_COM8,\n\t\t\tCOM8_FASTAEC | COM8_AECSTEP | COM8_BFILT | COM8_AGC | COM8_AEC\n\t\t\t\t\t| COM8_AWB);\n\n\tNVIC_InitTypeDef NVIC_InitStructure;\n\tNVIC_InitStructure.NVIC_IRQChannel = DCMI_IRQn;\n\tNVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;\n\tNVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;\n\tNVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\n\tNVIC_Init(&NVIC_InitStructure);\n\n\tDCMI_ITConfig(DCMI_IT_FRAME, ENABLE);\n\tDCMI_ITConfig(DCMI_IT_VSYNC, ENABLE);\n\tDCMI_ITConfig(DCMI_IT_LINE, ENABLE);\n\t// Enable DCMI Capture mode\n\tDCMI_Cmd(ENABLE);\n\tDCMI_CaptureCmd(ENABLE);\n\n\t// DMA Stream enable\n\tDMA_Cmd(DMA_CameraToRAM_Stream, ENABLE);\n\tunsigned int datachar[8] = { 0, 0, 0, 0, 0, 0, 0, 0 }, it = 0, cmd, arg,\n\t\t\tdata, jk;\n\twhile (1) {\n\t\twhile (USART_GetFlagStatus(USART2, USART_IT_RXNE) != RESET) {\n\t\t\tit++;\n\t\t\tif (it == 8) {\n\t\t\t\tit = 0;\n\t\t\t}\n\t\t\tdatachar[it] = USART_ReceiveData(USART2);\n\t\t\tif (datachar[it] == '\\n') {\n\t\t\t\tasm(\"nop\");\n\t\t\t}\n\t\t\tif (datachar[it] == '\\n' && datachar[it - 1] == '\\r') {\n\t\t\t\tcmd = datachar[1];\n\t\t\t\targ = datachar[2];\n\t\t\t\tdata = datachar[3];\n\t\t\t\tswitch (cmd) {\n\t\t\t\tcase '1':\n\t\t\t\t\tDCMI_Cmd(ENABLE);\n\t\t\t\t\tDCMI_CaptureCmd(ENABLE);\n\t\t\t\t\tDMA_Cmd(DMA_CameraToRAM_Stream, ENABLE);\n\t\t\t\t\tit = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2':\n\t\t\t\t\tov7670_set(arg, data);\n\t\t\t\t\tit = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tit = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tit = 0;\n\t\t\t\tfor (jk = 0; jk < 8; jk++) {\n\t\t\t\t\tdatachar[jk] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint num_dcmi = 0;\nint num_dcmi_frame = 0;\nint num_dcmi_vsync = 0;\nint num_dcmi_line = 0;\n\nvoid DCMI_IRQHandler(void) {\n\tnum_dcmi++;\n\n\tuint16_t i;\n\tif (DCMI_GetITStatus(DCMI_IT_FRAME)) {\n\t\t__disable_irq();\n\t\tfor (i = 0; i < picture_x * picture_y; i++)\n\t\t\tusartSendWord(RAM_Buffer[i]);\n\t\t__enable_irq();\n\t\tDCMI_Cmd(DISABLE);\n\t\tDCMI_CaptureCmd(DISABLE);\n\t\tDMA_Cmd(DMA_CameraToRAM_Stream, DISABLE);\n\n\t\tnum_dcmi_frame++;\n\t\tDCMI_ClearITPendingBit(DCMI_IT_FRAME);\n\t\t//printf(\" lines: %d\\n\\r\",num_dcmi_line);\n\t} else if (DCMI_GetFlagStatus(DCMI_FLAG_VSYNCRI) == SET) {\n\t\tnum_dcmi_vsync++;\n\t\tDCMI_ClearFlag(DCMI_FLAG_VSYNCRI);\n\t\t//printf(\" lines: %d\\n\\r\",num_dcmi_line);\n//\t\tprintf(\" num_dcmi: %d\\n\\r\",num_dcmi);\n//\t\tprintf(\" num_dcmi_frame: %d\\n\\r\",num_dcmi_frame);\n//\t\tprintf(\" num_dcmi_vsync: %d\\n\\r\",num_dcmi_vsync);\n//\t\tprintf(\" num_dcmi_line: %d\\n\\r\",num_dcmi_line);\n//\t\tprintf(\" =========================\\n\\r\");\n\t\tnum_dcmi = 0;\n\t\tnum_dcmi_frame = 0;\n\t\tnum_dcmi_vsync = 0;\n\t\tnum_dcmi_line = 0;\n\t} else if (DCMI_GetFlagStatus(DCMI_IT_LINE) == SET) {\n\t\tnum_dcmi_line++;\n\t\tDCMI_ClearFlag(DCMI_IT_LINE);\n\t}\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":17933}]],"length":17933}
{"contributors":[],"silentsave":false,"ts":1366959702655,"patch":[[{"diffs":[[0,"\n}\n\n"],[-1,"uint8_t ov7670_get(uint8_t reg) {\n\tuint8_t data = 0;\n\tI2C_start(I2C2, 0x42, I2C_Direction_Transmitter);\n\tI2C_write(I2C2, reg);\n\tI2C_stop(I2C2);\n\tdelay(1000);\n\tI2C_start(I2C2, 0x43, I2C_Direction_Receiver);\n\tdata = I2C_read_nack(I2C2);\n\tI2C_stop(I2C2);\n\tdelay(1000);\n\treturn data;\n}\nuint8_t ov7670_set(uint8_t reg, uint8_t data) {\n\tI2C_start(I2C2, 0x42, I2C_Direction_Transmitter);\n\tI2C_write(I2C2, reg);\n\tI2C_write(I2C2, data);\n\tI2C_stop(I2C2);\n\tdelay(1000);\n\treturn 0;\n}\n\n"],[0,"void"]],"start1":6216,"start2":6216,"length1":481,"length2":8},{"diffs":[[0,"();\n"],[-1,"\n\tif (ov7670_get(REG_PID) != 0x76) {\n\t\tprintf(\" PANIC! REG_PID != 0x76!\\n\");\n\t\twhile (1)\n\t\t\t;\n\t}\n\tov7670_set(REG_COM7, COM7_RESET); /* reset to default values */\n\tov7670_set(REG_CLKRC, 0x01);\n\tov7670_set(REG_COM7, COM7_FMT_VGA | COM7_YUV); /* output format: YUCV */\n\tint hstart = 456, hstop = 24, vstart = 14, vstop = 494;\n\tunsigned char v;\n\tov7670_set(REG_HSTART, (hstart >> 3) & 0xff);\n\tov7670_set(REG_HSTOP, (hstop >> 3) & 0xff);\n\tv = ov7670_get(REG_HREF);\n\tv = (v & 0xc0) | ((hstop & 0x7) << 3) | (hstart & 0x7);\n\tov7670_set(REG_HREF, v);\n\n\tov7670_set(REG_VSTART, (vstart >> 2) & 0xff);\n\tov7670_set(REG_VSTOP, (vstop >> 2) & 0xff);\n\tv = ov7670_get(REG_VREF);\n\tv = (v & 0xf0) | ((vstop & 0x3) << 2) | (vstart & 0x3);\n\tov7670_set(REG_VREF, v);\n\tov7670_set(REG_COM3, COM3_SCALEEN | COM3_DCWEN);\n\tov7670_set(REG_COM14, COM14_DCWEN | 0x01); // divide by 4 [RFC]\n\tov7670_set(0x73, 0xf1);\n\tov7670_set(0xa2, 0x52);\n\tov7670_set(0x7b, 0x1c);\n\tov7670_set(0x7c, 0x28);\n\tov7670_set(0x7d, 0x3c);\n\tov7670_set(0x7f, 0x69);\n\tov7670_set(REG_COM9, 0x38);\n\tov7670_set(0xa1, 0x0b);\n\tov7670_set(0x74, 0x19);\n\tov7670_set(0x9a, 0x80);\n\tov7670_set(0x43, 0x14);\n\tov7670_set(REG_COM13, 0xc0);\n\tov7670_set(0x70, 0x3A);\n\tov7670_set(0x71, 0x35);\n\tov7670_set(0x72, 0x11); // downsample by 2\n\n\t/* Gamma curve values */\n\tov7670_set(0x7a, 0x20);\n\tov7670_set(0x7b, 0x10);\n\tov7670_set(0x7c, 0x1e);\n\tov7670_set(0x7d, 0x35);\n\tov7670_set(0x7e, 0x5a);\n\tov7670_set(0x7f, 0x69);\n\tov7670_set(0x80, 0x76);\n\tov7670_set(0x81, 0x80);\n\tov7670_set(0x82, 0x88);\n\tov7670_set(0x83, 0x8f);\n\tov7670_set(0x84, 0x96);\n\tov7670_set(0x85, 0xa3);\n\tov7670_set(0x86, 0xaf);\n\tov7670_set(0x87, 0xc4);\n\tov7670_set(0x88, 0xd7);\n\tov7670_set(0x89, 0xe8);\n\n\t/* AGC and AEC parameters.  Note we start by disabling those features,\n\t then turn them only after tweaking the values. */\n\tov7670_set(REG_COM8, COM8_FASTAEC | COM8_AECSTEP | COM8_BFILT);\n\tov7670_set(REG_GAIN, 0);\n\tov7670_set(REG_AECH, 0);\n\tov7670_set(REG_COM4, 0x40); /* magic reserved bit */\n\tov7670_set(REG_COM9, 0x18); /* 4x gain + magic rsvd bit */\n\tov7670_set(REG_BD50MAX, 0x05);\n\tov7670_set(REG_BD60MAX, 0x07);\n\tov7670_set(REG_AEW, 0x95);\n\tov7670_set(REG_AEB, 0x33);\n\tov7670_set(REG_VPT, 0xe3);\n\tov7670_set(REG_HAECC1, 0x78);\n\tov7670_set(REG_HAECC2, 0x68);\n\tov7670_set(0xa1, 0x03); /* magic */\n\tov7670_set(REG_HAECC3, 0xd8);\n\tov7670_set(REG_HAECC4, 0xd8);\n\tov7670_set(REG_HAECC5, 0xf0);\n\tov7670_set(REG_HAECC6, 0x90);\n\tov7670_set(REG_HAECC7, 0x94);\n\tov7670_set(REG_COM8,\n\t\t\tCOM8_FASTAEC | COM8_AECSTEP | COM8_BFILT | COM8_AGC | COM8_AEC);\n\n\t/* Almost all of these are magic \"reserved\" values.  */\n\tov7670_set(REG_COM5, 0x61);\n\tov7670_set(REG_COM6, 0x4b);\n\tov7670_set(0x16, 0x02);\n\tov7670_set(REG_MVFP, 0x07);\n\tov7670_set(0x21, 0x02);\n\tov7670_set(0x22, 0x91);\n\tov7670_set(0x29, 0x07);\n\tov7670_set(0x33, 0x0b);\n\tov7670_set(0x35, 0x0b);\n\tov7670_set(0x37, 0x1d);\n\tov7670_set(0x38, 0x71);\n\tov7670_set(0x39, 0x2a);\n\tov7670_set(REG_COM12, 0x78);\n\tov7670_set(0x4d, 0x40);\n\tov7670_set(0x4e, 0x20);\n\tov7670_set(REG_GFIX, 0);\n\tov7670_set(0x6b, 0x4a);\n\tov7670_set(0x74, 0x10);\n\tov7670_set(0x8d, 0x4f);\n\tov7670_set(0x8e, 0);\n\tov7670_set(0x8f, 0);\n\tov7670_set(0x90, 0);\n\tov7670_set(0x91, 0);\n\tov7670_set(0x96, 0);\n\tov7670_set(0x9a, 0);\n\tov7670_set(0xb0, 0x84);\n\tov7670_set(0xb1, 0x0c);\n\tov7670_set(0xb2, 0x0e);\n\tov7670_set(0xb3, 0x82);\n\tov7670_set(0xb8, 0x0a);\n\n\t/* Matrix coefficients */\n\tov7670_set(0x4f, 0x80);\n\tov7670_set(0x50, 0x80);\n\tov7670_set(0x51, 0);\n\tov7670_set(0x52, 0x22);\n\tov7670_set(0x53, 0x5e);\n\tov7670_set(0x54, 0x80);\n\tov7670_set(0x58, 0x9e);\n\n\t/* More reserved magic, some of which tweaks white balance */\n\tov7670_set(0x43, 0x0a);\n\tov7670_set(0x44, 0xf0);\n\tov7670_set(0x45, 0x34);\n\tov7670_set(0x46, 0x58);\n\tov7670_set(0x47, 0x28);\n\tov7670_set(0x48, 0x3a);\n\tov7670_set(0x59, 0x88);\n\tov7670_set(0x5a, 0x88);\n\tov7670_set(0x5b, 0x44);\n\tov7670_set(0x5c, 0x67);\n\tov7670_set(0x5d, 0x49);\n\tov7670_set(0x5e, 0x0e);\n\tov7670_set(0x6c, 0x0a);\n\tov7670_set(0x6d, 0x55);\n\tov7670_set(0x6e, 0x11);\n\tov7670_set(0x6f, 0x9f); /* \"9e for advance AWB\" */\n\tov7670_set(0x6a, 0x40);\n\tov7670_set(REG_BLUE, 0x40);\n\tov7670_set(REG_RED, 0x60);\n\tov7670_set(REG_COM8,\n\t\t\tCOM8_FASTAEC | COM8_AECSTEP | COM8_BFILT | COM8_AGC | COM8_AEC\n\t\t\t\t\t| COM8_AWB);\n"],[1,"    ov7670_init();"],[0,"\n\tNV"]],"start1":10800,"start2":10800,"length1":4234,"length2":26}]],"length":13252,"saved":false}
{"ts":1366959822757,"patch":[[{"diffs":[[0,"\n}\n\n"],[-1,"void I2CInit(void) {\n\n\tGPIO_InitTypeDef GPIO_InitStructure;\n\tI2C_InitTypeDef I2C_InitStructure;\n\n\t/* Enable GPIO clock */\n\tRCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);\n\n\t/* Enable UART clock */\n\tRCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, ENABLE);\n\n\tGPIO_PinAFConfig(GPIOB, GPIO_PinSource10, GPIO_AF_I2C2);\n\tGPIO_PinAFConfig(GPIOB, GPIO_PinSource11, GPIO_AF_I2C2);\n\n\tGPIO_InitStructure.GPIO_OType = GPIO_OType_OD;\n\tGPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;\n\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;\n\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(GPIOB, &GPIO_InitStructure);\n\n\tI2C_InitStructure.I2C_ClockSpeed = 400000;\n\tI2C_InitStructure.I2C_Mode = I2C_Mode_I2C;\n\tI2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;\n\tI2C_InitStructure.I2C_OwnAddress1 = 0;\n\tI2C_InitStructure.I2C_Ack = I2C_Ack_Enable;\n\tI2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;\n\n\t/* Enable I2C */\n\tI2C_Cmd(I2C2, ENABLE);\n\tI2C_Init(I2C2, &I2C_InitStructure);\n}\n\nvoid I2C_start(I2C_TypeDef* I2Cx, uint8_t address, uint8_t direction) {\n\twhile (I2C_GetFlagStatus(I2Cx, I2C_FLAG_BUSY))\n\t\t;\n\tI2C_GenerateSTART(I2Cx, ENABLE);\n\twhile (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_MODE_SELECT))\n\t\t;\n\tI2C_Send7bitAddress(I2Cx, address, direction);\n\tif (direction == I2C_Direction_Transmitter) {\n\t\twhile (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))\n\t\t\t;\n\t} else if (direction == I2C_Direction_Receiver) {\n\t\twhile (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))\n\t\t\t;\n\t}\n}\n\nvoid I2C_write(I2C_TypeDef* I2Cx, uint8_t data) {\n\tI2C_SendData(I2Cx, data);\n\t// ждем I2C EV8_2 --> ask от ведомого\n\twhile (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))\n\t\t;\n}\n\nuint8_t I2C_read_ack(I2C_TypeDef* I2Cx) {\n\tuint8_t data;\n\t// разрешаем ask после приема\n\tI2C_AcknowledgeConfig(I2Cx, ENABLE);\n\t// ждем пока ведомый передаст байт\n\twhile (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_BYTE_RECEIVED))\n\t\t;\n\t// возвращаем принятое\n\tdata = I2C_ReceiveData(I2Cx);\n\treturn data;\n}\n\nuint8_t I2C_read_nack(I2C_TypeDef* I2Cx) {\n\tuint8_t data;\n\t//запрещаем ask после приема\n\tI2C_AcknowledgeConfig(I2Cx, DISABLE);\n\t// ждем пока ведомый передаст байт\n\twhile (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_BYTE_RECEIVED))\n\t\t;\n\t// возвращаем принятое\n\tdata = I2C_ReceiveData(I2Cx);\n\treturn data;\n}\n\nvoid I2C_stop(I2C_TypeDef* I2Cx) {\n\t//Отправляем STOP на линию\n\tI2C_GenerateSTOP(I2Cx, ENABLE);\n}"],[0,"\n\nst"]],"start1":3137,"start2":3137,"length1":2483,"length2":8}]],"length":10777,"saved":false}
{"ts":1366960018423,"patch":[[{"diffs":[[0,"144\n"],[-1,"//#define picture_x 160\n//#define picture_y 120"],[0,"\n__I"]],"start1":930,"start2":930,"length1":55,"length2":8}]],"length":10730,"saved":false}
{"contributors":[],"silentsave":false,"ts":1367314638819,"patch":[[{"diffs":[[0,"init();\n"],[1,"\n"],[0,"\tNVIC_In"]],"start1":8293,"start2":8293,"length1":16,"length2":17},{"diffs":[[0,"Buffer[i"],[1,"+2"],[0,"]);\n\t\t__"]],"start1":9901,"start2":9901,"length1":16,"length2":18}]],"length":10733,"saved":false}
